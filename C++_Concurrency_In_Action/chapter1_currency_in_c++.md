
C++11在语言和库层面了有了比较大的改动。

新标准最重要的一个特性就是有了支持多线程库，多线程不再需要依赖特定平台了。

### 1.1 什么是并发？
并发就是多个独立的行为同时发生。

#### 1.1.1 电脑系统中的并发
就电脑而讨论并发时，我们是指任务并行，而不是串行执行任务。例如，通过task快速切换可以有假的并发。

#### 1.1.2 实现并发方法
* 多进程并发
优点：进程有独立的内部通信通道（signals，socket，files，pipes）；可以运行在不同机器，尽管通信开销难一些。
缺点：进程间通信难，创建进程耗时，管理进程需要更多资源。


* 多线程并发
优点：线程可以看做轻量级进程，创建开销小；共享进程地址空间，数据共享方便。
缺点：多线程共享数据，要确保数据一致性。

### 1.2为什么使用并发
使用多线程主要有两个原因：关注点分离(Separation of Concerns）和性能。

#### 1.2.1  关注点分离
从功能角度来说，不同线程执行不同功能，代码易于理解和测试。

#### 1.2.2  性能
即并行处理。分为任务并行和数据并行。

#### 1.2.3 合适不用并发
收益小于代价时，不用并发。例如并发使得编码复杂，容易导致bugs。
多线程的代价包括OS分配内核资源、栈空间、调度；线程之间的切换等。
线程是有限资源。32位系统有4G空间，如果线程有1M栈空间（许多系统默认），最多可以创建4096个线程（还没有统计代码段、静态数据等）。线程池可以限制线程数量，但它也有自己的问题（第九章）。
线程之间调度切换需要时间；线程过多会降低性能。


### 1.3 C++中的并发和多线程
C++11已经支持多线程了。之前版本需要platform-specific来支持多线程。

#### 1.3.1 C++多线程历史
1998年制订的C++标准不支持多线程，也没有定义memory model。需要特定的编译器扩展才能编写多线程应用。
编译器除了添加拓展，可以添加C APIs支持多线程，例如POSIX C、Microsoft Windows API。这些特定的C APIs也是根据不同平台实现的。
一些应用框架MFC、Boost、ACE提供更高层次的多线程库，不过也是通过封装各种不同平台的库实现的。

上面这些实现，缺乏标准的支持，没有统一的memory model，容易引起问题；例如不同代码在不同平台编译器实现不同。

vendorsvendors#### 1.3.2 
一些高性能计算的开发者担心C++类知识封装了low-level facilities。如果最关心性能，对比high-level和low-level抽象之间的差异，就是抽象代价（abstraction penalty)。

C++标准委员会考虑到了这点，C++标准库和C++线程库的设计目标时没有抽象代价或抽象代价很小。










