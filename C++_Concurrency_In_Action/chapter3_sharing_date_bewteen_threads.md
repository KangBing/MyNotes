## Sharing data between threads
同一个进程之间的线程共享数据方式比较简单；共享数据时要确保数据一致，避免因为竞争引起的问题。

### 3.1 线程之间共享数据的问题
线程之间共享数据问题的根源是修改数据。如果所有的共享数据都是*read-only*，就不存在共享数据的问题了。

#### 3.1.1 条件竞争
条件竞争，是指在多线程并发执行中；结果依赖线程的执行顺序。有时候结果是良性的，因为我们可以接受任何一个结果。当讨论条件竞争时，常常是指有问题的条件竞争，不是指良性条件竞争。C++标准定义了条件竞争：多个线程修改同一个对象，引起未定义行为。

#### 3.1.2 避免有问题的条件竞争
最简单的办法就是提供一种保护机制，同一时刻只有一个线程可以修改数据，可以看到修改过程中的中间状态；对于其他线程，要么修改还没卡开始，要么修改已经完成。

还有一种就是修改数据结构的设计，修改是一系列不可拆分的变化。这也是通常说的*无锁编程*，比较难得到正确结果。在这一级别编程，内存模型的细微差别，不同线程访问不同数据，都将变得更加复杂。

另外一种方式是把修改当做*事务*。这点类似数据库的概念。

C++标准库提供的保护共享数据最基本的机制是*mutex*。

### 3.2 使用互斥量保护共享数据