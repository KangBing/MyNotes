## 第5章 C++内存模型和原子操作

这一章主要包括：
* C++11中的内存模型
* C++标准库提供的原子类型
* 原子类型上的操作
* 如果使用这些操作在线程间同步

C++11中最重要的特性并不是新的语法特性，也不是库提供的便利；而是线程可感知的内存模型。内存模型决定了基础的模块如何工作，是语法便利的基础。如果只是简单使用互斥量、条件变量、futures信号事件等，它们如何工作的原理不需要了解。如果要知道其底层原理，那么就需要了解内存模型。

C++是系统语言，标准委员会的一个目标是不应该存在比C++更低级的语言。C++应该提供足够便利，如果不能满足需求，那么就使用更低层操作（clost to the machine）。原子类型和操作就是这样的操作，可以减少CPU指令。

这一章首先讲解内存模型基本知识，然后是原子类型和原子操作，最后是各种原子类型的同步操作。内容比较复杂难懂：除非你使用原子操作来同步（例如设计无锁数据结构），否则没必要了解这些细节。

### 5.4 内存模型基本知识
提到内存模型，有两方面含义：数据结构（数据如何在内存中存放的）、线程并发。数据结构方面对于并发非常重要，尤其是要了解原子操作时。在C++中所有内容都是关于对象和内存位置（memory location）。

#### 5.1.1 对象和内存位置
C++中所有数据都由对象组成。C++标准定义对象为“一块存储区域”，还有其他一些特性例如赋值、类型、生命周期。
这些对象可以是简单的基本数值类型，例如`int`, `float`，也可能是用户自定义类型；还可能是数组、无static数据的派生类实例。
不管对象是什么类型，它总是存储在一个或多个内存位置。一个内存位置或者是对象（子对象），或者是标量类型（例如`unsigned short`）或指针，或邻近的bit fields（邻近的bit fields是不同的对象，但是常常当做同一块内存位置）。
总结一下有四点:
* 一个变量是一个对象，包括对象的成员变量
* 一个对象至少占有一个内存位置
* 基本数据类型只占用一处内存位置，即使它们是数组成员
* 邻近的bit fields占用同一位置内存的不同部分

#### 5.1.2 对象，内存位置，并发
C++中所有对象都对应内存中一个位置。在并发程序中，如果两个线程访问不同内存，不会有问题；如果访问同一位置内存，且只是read-only，也不会有问题；但是如果有一个线程修改内存位置对象，就有条件竞争问题。
为了避免条件竞争，两个线程访问要有一定的顺序。一种方法是使用互斥量，先给互斥量上锁的线程可以优先访问；同一时间只有一个线程可以访问。这是一种happen-before关系。还有一种方法是使用原子操作（5.2节）。
如果不确保访问顺序，且访问不是原子操作，那么就有数据经常，出现未定义行为。
未定义行为是C++中最糟糕的情况之一。根据C++标准，只有包含未定义行为，那么整个程序都是未定义的，可能出现任何情况。数据竞争是很严重的bug，要不惜任何代价避免。
使用原子操作避免未定义行为，但是要注意原子操作并没有阻止竞争本身-原子操作没有指定访问顺序-但是它把未定义行为降级为定义行为。
在学习原子操作前，先来看一个概念：修改顺序；这对于理解对象和内存位置都有帮助。

#### 5.1.3 修改顺序


